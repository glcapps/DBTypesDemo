<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DuckDB-Wasm in Browser</title>

    <script src="https://unpkg.com/htmx.org@1.9.5"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        function base64ToUint8Array(base64) {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
                if (bytes[i] > 255) {
                throw new Error("Either atob or string iteration is not spec compliant, please make sure your runtime is supported");
                }
            }
            return bytes;
        }
    </script>
    <!-- Load Monaco separately to avoid exceptions breaking other functionality -->
    <script>
        (function() {
            try {
                var monacoScript = document.createElement("script");
                monacoScript.src = "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.39.0/min/vs/loader.js";
                monacoScript.onload = function() {
                    require.config({ paths: { vs: "https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.39.0/min/vs" } });
                    require(["vs/editor/editor.main"], function () {
                        window.monacoLoaded = true;
                        console.log("Monaco Editor Loaded Successfully");
                    });
                };
                document.head.appendChild(monacoScript);
            } catch (e) {
                console.error("Failed to load Monaco Editor:", e);
            }
        })();
    </script>

    <!-- Load Apache Arrow explicitly -->
    <script type="module">
        import * as arrow from "https://cdn.jsdelivr.net/npm/apache-arrow@19.0.0/Arrow.es2015.min.js";
        window.arrow = arrow;
    </script>
    <!-- Load all dependencies locally -->
    <script type="module">
        // import * as arrow from "./apache-arrow-mjs.js";   
        import * as tslib from "./tslib-mjs.js";         
        import * as flatbuffers from "./flatbuffers-mjs.js"; 
        import * as duckdb from "./duckdb-browser-mjs.js";  

        // Ensure global access to dependencies
        window.arrow = arrow;
        window.tslib = tslib;
        window.flatbuffers = flatbuffers;
        window.duckdb = duckdb;
        window.duckDBReady = false; // Mark DuckDB as not ready initially

        async function initDuckDB() {
            console.log("Initializing DuckDB...");

            const MANUAL_BUNDLES = {
                mvp: {
                    mainModule: "./duckdb-mvp.wasm",
                    mainWorker: "./duckdb-browser-mvp.worker.js",
                },
            };

            // Select the appropriate bundle
            const bundle = await duckdb.selectBundle(MANUAL_BUNDLES);
            console.log("Bundle Selected:", bundle);

            // Create a worker with the correct path
            const worker = new Worker(bundle.mainWorker);
            const logger = new duckdb.ConsoleLogger();

            // Instantiate DuckDB with explicit Arrow module
            const db = new duckdb.AsyncDuckDB(logger, worker);
            await db.instantiate(bundle.mainModule, bundle.pthreadWorker, {
                arrowModule: window.arrow, // Ensure Apache Arrow is correctly passed
            });

            console.log("DuckDB Successfully Initialized.");
            window.duckDB = db; // Store DuckDB globally
            window.duckDBReady = true; // Mark DuckDB as ready
        }

        // Wait for DuckDB to initialize before running queries
        await initDuckDB();
    </script>
</head>
<body class="bg-gray-900 text-white p-6">
    <div class="max-w-4xl mx-auto">
        <h1 class="text-2xl font-bold mb-4">DataBase Appreciation Talk</h1>
        <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
            <h2 class="text-lg font-semibold mb-2">DuckDB Query</h2>
            <div class="flex gap-2 mb-2">
                <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded" onclick="prefillDuckDBQuery(0)">Sample Query 1</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded" onclick="prefillDuckDBQuery(1)">Sample Query 2</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded" onclick="prefillDuckDBQuery(2)">Sample Query 3</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded" onclick="prefillDuckDBQuery(3)">Sample Query 4</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded" onclick="prefillDuckDBQuery(4)">Sample Query 5</button>
            </div>
            <div id="duckdb-editor" class="h-40 border rounded bg-gray-700"></div>
            <button class="mt-2 bg-blue-500 hover:bg-blue-700 text-white px-4 py-2 rounded" onclick="runDuckDBQuery()">Run Query</button>
            <pre id="duckdb-output" class="bg-gray-700 p-2 mt-2 rounded" style="max-height: 300px; overflow: scroll;"></pre>
        </div>
    </div>

    <script>
        async function runDuckDBQuery() {
            if (!window.duckDBReady) {
                document.getElementById("duckdb-output").textContent = "Error: DuckDB not initialized. Please wait...";
                return;
            }

            const query = window.duckDBEditor.getValue();
            try {
                const conn = await window.duckDB.connect();
                const result = await conn.query(query);
                document.getElementById("duckdb-output").textContent = JSON.stringify(result.toArray(), null, 2);
                conn.close();
            } catch (error) {
                document.getElementById("duckdb-output").textContent = "Error: " + error.message;
            }
        }

        (function waitForMonaco() {
            if (window.monacoLoaded) {
                window.duckDBEditor = monaco.editor.create(document.getElementById("duckdb-editor"), {
                    value: `SELECT 'Hello, World' AS "greeting"`,
                    language: "sql",
                    theme: "vs-dark"
                });
            } else {
                setTimeout(waitForMonaco, 100);
            }
        })();
    </script>
    <script>
        function prefillDuckDBQuery(queryIndex) {
            const queries = [
                `SELECT * 
FROM 'https://shell.duckdb.org/data/tpch/0_01/parquet/lineitem.parquet'
LIMIT 100;`,
                `SELECT COUNT(*)::STRING AS "count"
FROM 'https://shell.duckdb.org/data/tpch/0_01/parquet/lineitem.parquet';`,
                `SELECT l_shipmode, l_quantity, l_shipdate
FROM 'https://shell.duckdb.org/data/tpch/0_01/parquet/lineitem.parquet' 
LIMIT 100;`,
                `SELECT n_name AS 'NationName',
AVG(c_acctbal) AS 'AverageBalance'
FROM
    'https://shell.duckdb.org/data/tpch/0_01/parquet/customer.parquet',
    'https://shell.duckdb.org/data/tpch/0_01/parquet/nation.parquet'
WHERE 1=1
AND c_nationkey = n_nationkey
GROUP BY n_name;`,
`SELECT *
FROM READ_CSV_AUTO('https://docs.google.com/spreadsheets/d/1fy3GbhVC8iuA9JZTqhzG3Ij_8nIn_PoZnZK2ofpZ0rs/gviz/tq?tqx=out:csv');`,
`LOAD autocomplete;
SELECT *
FROM sql_auto_complete('SELECT * FRO');`
            ];
            if (window.duckDBEditor && queries[queryIndex]) {
                window.duckDBEditor.setValue(queries[queryIndex]);
            }
        }
    </script>

    <script>
        (function loadPgMock() {
            return
            try {
                var pgMockScript = document.createElement("script");
                pgMockScript.src = "https://cdn.jsdelivr.net/npm/pgmock@latest";
                pgMockScript.onload = function() {
                    console.log("pgMock Loaded Successfully");
                    window.pgMockInstance = new pgMock();
                };
                document.head.appendChild(pgMockScript);
            } catch (e) {
                console.error("Failed to load pgMock:", e);
            }
        })();
    </script>
    
    <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
        <h2 class="text-lg font-semibold mb-2">PostgreSQL Query</h2>
        <div id="pg-editor" class="h-40 border rounded bg-gray-700"></div>
        <button class="mt-2 bg-green-500 hover:bg-green-700 text-white px-4 py-2 rounded" onclick="runPGQuery()">Run Query</button>
        <pre id="pg-output" class="bg-gray-700 p-2 mt-2 rounded"></pre>
    </div>
    
    <script>
        document.getElementById("pg-output").textContent = "pgMock under construction. Please disregard...";
        (function waitForMonacoForPG() {
            if (window.monacoLoaded) {
                window.pgEditor = monaco.editor.create(document.getElementById("pg-editor"), {
                    value: "SELECT 'Hello, World!' AS message;",
                    language: "sql",
                    theme: "vs-dark"
                });
            } else {
                setTimeout(waitForMonacoForPG, 100);
            }
        })();

        function runPGQuery() {
            if (!window.pgMockInstance) {
                document.getElementById("pg-output").textContent = "Error: pgMock not initialized. Please wait...";
                return;
            }

            try {
                const result = window.pgMockInstance.query("SELECT 'Hello, World!' AS message;");
                document.getElementById("pg-output").textContent = JSON.stringify(result.rows, null, 2);
            } catch (error) {
                document.getElementById("pg-output").textContent = "Error: " + error.message;
            }
        }
    </script>
    <script>
        (function enableSQLIntelliSense() {
            if (window.monacoLoaded) {
                monaco.languages.registerCompletionItemProvider("sql", {
                    provideCompletionItems: function (model, position) {
                        var word = model.getWordUntilPosition(position);
                        var range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endColumn: word.endColumn,
                        };
                
                        const sqlKeywords = [
                            "SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE", "JOIN", 
                            "ORDER BY", "GROUP BY", "HAVING", "DISTINCT", "AS", "AND", "OR", 
                            "NOT", "NULL", "IS", "IN", "EXISTS", "BETWEEN", "CASE", "WHEN", 
                            "THEN", "ELSE", "END", "LIMIT", "OFFSET", "CREATE", "ALTER", 
                            "DROP", "TABLE", "INDEX", "VIEW", "TRIGGER", "PRIMARY KEY", 
                            "FOREIGN KEY", "CHECK", "DEFAULT", "UNIQUE"
                        ];
                
                        return {
                            suggestions: sqlKeywords.map(keyword => ({
                                label: keyword,
                                kind: monaco.languages.CompletionItemKind.Keyword,
                                insertText: keyword + " ", // Adds trailing space
                                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet, // Ensures proper insertion
                                range: range,
                            }))
                        };
                    }
                });
                console.log("SQL IntelliSense Enabled");
            } else {
                setTimeout(enableSQLIntelliSense, 100);
            }
        })();
    </script>
    
</body>
</html>
